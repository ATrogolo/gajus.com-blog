<p>There are many articles about JavaScript generators:</p>

<ul>
    <li>http://odetocode.com/blogs/scott/archive/2014/02/17/thoughts-on-javascript-generators.aspx</li>
    <li>http://truffles.me.uk/playing-with-es6-generators-to-make-a-maybe-in-javascript</li>
    <li>http://devsmash.com/blog/whats-the-big-deal-with-generators</li>
    <li>http://luisvega.me/understanding-node-generators</li>
    <li>http://webreflection.blogspot.com/2013/06/on-harmony-javascript-generators.html</li>
    <li>http://blog.alexmaccaw.com/how-yield-will-transform-node</li>
    <li>http://tobyho.com/2013/06/16/what-are-generators/</li>
</ul>

<p>Nonetheless, I have struggled to understand the execution order and use cases. I have summarized the learning process that got me to understanding ES6 generators.</p>

<h2>Building an Iterator from a Generator</h2>

<code data-gist-id="59078d3e471c31146d9e"></code>

<p><code>generatorFunction</code> variable is assigned a <dfn>generator function</dfn>. Generator functions are denoted using <code>function *</code> syntax.</p>

<p>Calling a generator function returns an <dfn>iterator object</dfn>.</p>

<code data-gist-id="207325138bd1b168fa6e"></code>

<h2>Advancing the Generator</h2>

<p><code>next()</code> method is used to advance the execution of the generator body:</p>

<code data-gist-id="f297aa7504f1f78a72a7"></code>

<p><code>next()</code> method returns an object that indicates the progress of the iteration:</p>

<code data-gist-id="50630c4f46941486b9fb"></code>

<p><code>done</code> property indicates that the generator body has been run to the completion.</p>

<p>The generator function is expected to utilize <code>yield</code> keyword. <code>yield</code> suspends execution of a generator and returns control to the iterator.</p>

<code data-gist-id="53be682dbd812f04cb3d"></code>

<p>When suspended, the generator does not block the event queue:</p>

<code data-gist-id="b0c28574702885c86463"></code>

<h2>Pass a Value To the Iterator</h2>

<p><code>yield</code> keyword can pass a value back to the iterator:</p>

<code data-gist-id="e890da30e4f35c0fa520"></code>

<p>Any data type can be yielded, including functions, numbers, arrays and objects.</p>

<p>When the generator is advanced to the completion, the <code>return</code> value is returned.</p>

<code data-gist-id="cf2f35c7846c4431730b"></code>

<h2>Receive a Value From the Iterator</h2>

<p><code>yield</code> keyword can receive a value back from the iterator:</p>

<code data-gist-id="e547c4e1463ee06e9c71"></code>

<p>There is no <code>yield</code> expression to receive the first value "foo". The value is tossed-away.</p>

<h2>Understanding the Execution Flow</h2>

<p>The best way to understand the execution flow of the generators is to play around using a <code>debugger</code>. I have illustrated the example that I have used to wrap my head around the I/O order.</p>

<figure class="image">
    <img src="./generators.gif">
    <figcaption>Animated execution flow of the ES6 generators.</figcaption>
</figure>

<h2>Iterating Using the <code>for...of</code> Statement</h2>

<p>The iterator object returned from the generator is compliant with the "iterable" protocol (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable). Therefore, you can use the <code>for...of</code> statement (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) to loop through the generator.</p>

<code data-gist-id="d16ceb1b0b664405a63b"></code>

<ul>
    <li>The iteration will continue until <code>done</code> property is <code>false</code>.</li>
    <li>The <code>for..of</code> loop cannot be used in cases where you need to pass in values to the generator steps.</li>
    <li>The <code>for..of</code> loop will throw away the <code>return</code> value.</li>
</ul>

<h2>Throw</h2>

<p>In addition to advancing the generator instance using <code>next()</code>, you can <code>throw()</code>. Whatever is thrown will propagate back up into the code of the generator, i.e. it can be handled either within or outside the generator instance:</p>

<code data-gist-id="9a2b736fbf1773e11ed7"></code>

<p>Any data type can be thrown, including functions, numbers, arrays and objects.</p>

<h2>What Problem Do Generators Solve?</h2>

<p>In JavaScript, IO operations are generally done as asynchronous operations that require a callback. For the purpose of illustration, I am going to use a made-up service <code>foo</code>:</p>

<code data-gist-id="128d8c5d03a729c5a5d7"></code>

<p>Multiple asynchronous operations one after another produce nesting that is hard to read.</p>

<code data-gist-id="e29acea7c19fbfe34e3e"></code>

<p>There are several solutions to address the issue, such as using promises (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or generators. Using generators, the above code can be rewritten as such:</p>

<code data-gist-id="8f93418f93bb861a18e7"></code>

<p>To execute the generator, we need a controller. The controller needs to fulfill the asynchronous requests and return the result back.</p>

<code data-gist-id="551cd1989471d85837e8"></code>

<p>The last step is to curry the asynchronous functions into functions that take a single parameter (the callback). This allows to iterate the generator instance knowing that <code>yield</code> expression is always expecting a singe parameter, the callback that is used to further advance the iteration.</p>

<code data-gist-id="99d17383f55f8bd49dab"></code>

<p>The end result is a script without too many levels of nested callbacks and achieved line independence (the code for one operation is no longer tied to the ones that come after it).</p>

<code data-gist-id="89b345cac0fe2ae13986"></code>

<h2>Error Handling</h2>

<p>It is common to handle the error handling for each individual asynchronous operation, e.g.</p>

<code data-gist-id="93e39b5717724b82b6aa"></code>

<p>In the following example, I enable the controller to throw an error and use <code>try...catch</code> block to capture all errors.</p>

<code data-gist-id="92a16147195af3c87114"></code>

<p>Notice that the execution was interrupted before <code>curry(foo, 'c')</code> was called.</p>

<h2>Libraries</h2>

<p>There are several generator based flow-control libraries:</p>

<ul>
    <li>https://github.com/jmar777/suspend</li>
    <li>https://github.com/visionmedia/co</li>
    <li>https://github.com/bjouhier/galaxy</li>
    <li>https://github.com/spion/genny</li>
    <li>https://github.com/creationix/gen-run</li>
</ul>